# Story 2.3: Workout Program - Data Model & Backend

## Status: Done

## Story
**As a** developer,
**I want** workout program models supporting both simple exercises and supersets,
**so that** users can create structured training programs with advanced configurations.

## Acceptance Criteria
1. Modèle `Workout` créé (id, userId, name, description nullable, createdAt, updatedAt)
2. Modèle `WorkoutItem` créé pour représenter soit un exercice simple, soit un superset
3. Modèle `WorkoutItemExercise` créé pour les exercices dans un item (simple ou superset)
4. Modèle `WorkoutSet` créé pour la configuration détaillée de chaque set (reps, weight)
5. Support des **supersets** : un WorkoutItem peut contenir plusieurs exercices avec un nombre de tours
6. **Temps de repos personnalisé** entre chaque WorkoutItem (pas de repos global)
7. Endpoints API CRUD complets avec nested create/update
8. Cascade delete : supprimer un workout supprime tous les items associés
9. Validation : workout doit avoir au moins 1 item pour être valide

## Tasks / Subtasks
- [x] Créer modèles Prisma (AC: 1, 2, 3, 4, 5)
  - [x] Migration Prisma pour Workout
  - [x] Migration Prisma pour WorkoutItem (type: 'exercise' | 'superset', position, rounds, restAfter)
  - [x] Migration Prisma pour WorkoutItemExercise (exerciseId, position, restBetweenSets)
  - [x] Migration Prisma pour WorkoutSet (setNumber, targetReps, targetWeight)
  - [x] Relations et index appropriés
- [x] Créer endpoints CRUD (AC: 7)
  - [x] GET /workouts - liste des workouts de l'utilisateur
  - [x] GET /workouts/:id - workout complet avec items, exercices et sets
  - [x] POST /workouts - créer workout avec structure complète
  - [x] PUT /workouts/:id - modifier workout (remplacement complet des items)
  - [x] DELETE /workouts/:id - supprimer workout
  - [x] POST /workouts/:id/duplicate - dupliquer un workout
- [x] Implémenter nested create/update (AC: 7)
  - [x] Transaction pour création atomique
  - [x] Valider que tous les exerciseId existent
  - [x] Recalculer positions après modifications
- [x] Configurer cascade delete (AC: 8)
  - [x] onDelete: Cascade sur toutes les relations
  - [x] Tester suppression complète
- [x] Validation Zod (AC: 9)
  - [x] Au moins 1 item requis
  - [x] Superset doit avoir au moins 2 exercices
  - [x] Exercice simple doit avoir exactement 1 exercice
  - [x] Sets: reps > 0, weight >= 0, rounds > 0

## Dependencies
- Story 1.2: Database & Prisma Setup (Prisma 7 configuration)
- Story 2.1: Exercise Library Backend (modèle Exercise pour relations)

## Dev Notes

### Prisma 7 Configuration (ref Story 1.2)
- La config datasource est dans `prisma.config.ts` (pas dans schema.prisma)
- Le client est généré dans `src/generated/prisma/`
- Utiliser `moduleFormat = "cjs"` dans le generator
- Import Prisma: `import { prisma } from '../lib/prisma'`

### Architecture Conceptuelle

```
Workout
├── id, name, description, userId
└── items[] (ordonnés par position)
    │
    ├── WorkoutItem (type: "exercise")
    │   ├── position: 1
    │   ├── rounds: 1 (toujours 1 pour exercice simple)
    │   ├── restAfter: 120 (secondes, pause après cet item)
    │   └── exercises[] (1 seul pour exercice simple)
    │       └── WorkoutItemExercise
    │           ├── exerciseId
    │           ├── position: 1
    │           ├── restBetweenSets: 90
    │           └── sets[]
    │               ├── { setNumber: 1, targetReps: 10, targetWeight: 60 }
    │               ├── { setNumber: 2, targetReps: 10, targetWeight: 60 }
    │               └── { setNumber: 3, targetReps: 8, targetWeight: 65 }
    │
    └── WorkoutItem (type: "superset")
        ├── position: 2
        ├── rounds: 3 (nombre de tours du superset)
        ├── restAfter: 180 (pause après le superset complet)
        └── exercises[] (2+ pour superset)
            ├── WorkoutItemExercise (Développé couché)
            │   ├── exerciseId, position: 1
            │   ├── restBetweenSets: 0 (pas de repos dans superset)
            │   └── sets[]
            │
            └── WorkoutItemExercise (Élévation latérale)
                ├── exerciseId, position: 2
                ├── restBetweenSets: 0
                └── sets[]
```

### Prisma Schema

```prisma
model Workout {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  user        User     @relation(fields: [userId], references: [id])
  name        String
  description String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  items    WorkoutItem[]
  sessions WorkoutSession[]

  @@map("workouts")
}

model WorkoutItem {
  id        String   @id @default(uuid())
  workoutId String   @map("workout_id")
  workout   Workout  @relation(fields: [workoutId], references: [id], onDelete: Cascade)
  type      String   // 'exercise' | 'superset'
  position  Int      // ordre dans le workout
  rounds    Int      @default(1) // nombre de tours (1 pour exercice simple, N pour superset)
  restAfter Int      @map("rest_after") // secondes, repos après cet item

  exercises WorkoutItemExercise[]

  @@index([workoutId, position])
  @@map("workout_items")
}

model WorkoutItemExercise {
  id              String      @id @default(uuid())
  workoutItemId   String      @map("workout_item_id")
  workoutItem     WorkoutItem @relation(fields: [workoutItemId], references: [id], onDelete: Cascade)
  exerciseId      String      @map("exercise_id")
  exercise        Exercise    @relation(fields: [exerciseId], references: [id])
  position        Int         // ordre dans l'item (1 pour simple, 1-N pour superset)
  restBetweenSets Int         @map("rest_between_sets") // secondes

  sets WorkoutSet[]

  @@index([workoutItemId, position])
  @@map("workout_item_exercises")
}

model WorkoutSet {
  id                    String              @id @default(uuid())
  workoutItemExerciseId String              @map("workout_item_exercise_id")
  workoutItemExercise   WorkoutItemExercise @relation(fields: [workoutItemExerciseId], references: [id], onDelete: Cascade)
  setNumber             Int                 @map("set_number")
  targetReps            Int                 @map("target_reps")
  targetWeight          Float?              @map("target_weight") // kg, nullable

  @@index([workoutItemExerciseId, setNumber])
  @@map("workout_sets")
}
```

### API Request/Response

```typescript
// POST /workouts - Créer un workout complet
interface CreateWorkoutRequest {
  name: string;
  description?: string;
  items: WorkoutItemInput[];
}

interface WorkoutItemInput {
  type: 'exercise' | 'superset';
  position: number;
  rounds: number; // 1 pour exercice simple, N pour superset
  restAfter: number; // secondes
  exercises: WorkoutItemExerciseInput[];
}

interface WorkoutItemExerciseInput {
  exerciseId: string;
  position: number;
  restBetweenSets: number; // secondes
  sets: WorkoutSetInput[];
}

interface WorkoutSetInput {
  setNumber: number;
  targetReps: number;
  targetWeight?: number; // kg
}

// GET /workouts/:id - Réponse complète
interface WorkoutResponse {
  id: string;
  name: string;
  description: string | null;
  items: {
    id: string;
    type: 'exercise' | 'superset';
    position: number;
    rounds: number;
    restAfter: number;
    exercises: {
      id: string;
      exerciseId: string;
      exercise: { id: string; name: string; muscleGroups: string[] };
      position: number;
      restBetweenSets: number;
      sets: {
        id: string;
        setNumber: number;
        targetReps: number;
        targetWeight: number | null;
      }[];
    }[];
  }[];
  createdAt: string;
  updatedAt: string;
}
```

### Exemples de Payloads

```json
// Exercice simple: Bench Press 4x10 @ 60kg
{
  "type": "exercise",
  "position": 1,
  "rounds": 1,
  "restAfter": 120,
  "exercises": [{
    "exerciseId": "uuid-bench-press",
    "position": 1,
    "restBetweenSets": 90,
    "sets": [
      { "setNumber": 1, "targetReps": 10, "targetWeight": 60 },
      { "setNumber": 2, "targetReps": 10, "targetWeight": 60 },
      { "setNumber": 3, "targetReps": 10, "targetWeight": 60 },
      { "setNumber": 4, "targetReps": 10, "targetWeight": 60 }
    ]
  }]
}

// Superset: Développé couché + Élévation latérale, 3 tours
{
  "type": "superset",
  "position": 2,
  "rounds": 3,
  "restAfter": 180,
  "exercises": [
    {
      "exerciseId": "uuid-bench-press",
      "position": 1,
      "restBetweenSets": 0,
      "sets": [
        { "setNumber": 1, "targetReps": 12, "targetWeight": 50 }
      ]
    },
    {
      "exerciseId": "uuid-lateral-raise",
      "position": 2,
      "restBetweenSets": 0,
      "sets": [
        { "setNumber": 1, "targetReps": 15, "targetWeight": 8 }
      ]
    }
  ]
}
```

### Service Implementation

```typescript
// workout.service.ts
async createWorkout(userId: string, data: CreateWorkoutInput) {
  return prisma.$transaction(async (tx) => {
    // Valider que tous les exerciseId existent
    const exerciseIds = data.items.flatMap(item =>
      item.exercises.map(e => e.exerciseId)
    );
    const exercises = await tx.exercise.findMany({
      where: { id: { in: exerciseIds } }
    });
    if (exercises.length !== new Set(exerciseIds).size) {
      throw new Error('Un ou plusieurs exercices n\'existent pas');
    }

    // Créer le workout avec toute la structure imbriquée
    return tx.workout.create({
      data: {
        userId,
        name: data.name,
        description: data.description,
        items: {
          create: data.items.map(item => ({
            type: item.type,
            position: item.position,
            rounds: item.rounds,
            restAfter: item.restAfter,
            exercises: {
              create: item.exercises.map(ex => ({
                exerciseId: ex.exerciseId,
                position: ex.position,
                restBetweenSets: ex.restBetweenSets,
                sets: {
                  create: ex.sets.map(set => ({
                    setNumber: set.setNumber,
                    targetReps: set.targetReps,
                    targetWeight: set.targetWeight,
                  })),
                },
              })),
            },
          })),
        },
      },
      include: {
        items: {
          orderBy: { position: 'asc' },
          include: {
            exercises: {
              orderBy: { position: 'asc' },
              include: {
                exercise: true,
                sets: { orderBy: { setNumber: 'asc' } },
              },
            },
          },
        },
      },
    });
  });
}

// Mise à jour: supprimer tous les items et recréer
async updateWorkout(workoutId: string, userId: string, data: UpdateWorkoutInput) {
  return prisma.$transaction(async (tx) => {
    // Vérifier que le workout appartient à l'utilisateur
    const existing = await tx.workout.findFirst({
      where: { id: workoutId, userId }
    });
    if (!existing) throw new Error('Workout non trouvé');

    // Supprimer tous les items existants (cascade supprime exercises et sets)
    await tx.workoutItem.deleteMany({ where: { workoutId } });

    // Recréer avec les nouvelles données
    return tx.workout.update({
      where: { id: workoutId },
      data: {
        name: data.name,
        description: data.description,
        items: {
          create: data.items.map(item => ({
            type: item.type,
            position: item.position,
            rounds: item.rounds,
            restAfter: item.restAfter,
            exercises: {
              create: item.exercises.map(ex => ({
                exerciseId: ex.exerciseId,
                position: ex.position,
                restBetweenSets: ex.restBetweenSets,
                sets: {
                  create: ex.sets.map(set => ({
                    setNumber: set.setNumber,
                    targetReps: set.targetReps,
                    targetWeight: set.targetWeight,
                  })),
                },
              })),
            },
          })),
        },
      },
      include: { /* ... même include */ },
    });
  });
}
```

### Zod Validation

```typescript
const workoutSetSchema = z.object({
  setNumber: z.number().int().min(1),
  targetReps: z.number().int().min(1).max(100),
  targetWeight: z.number().min(0).max(500).optional(),
});

const workoutItemExerciseSchema = z.object({
  exerciseId: z.string().uuid(),
  position: z.number().int().min(1),
  restBetweenSets: z.number().int().min(0).max(600), // max 10 min
  sets: z.array(workoutSetSchema).min(1, 'Au moins 1 set requis'),
});

const workoutItemSchema = z.object({
  type: z.enum(['exercise', 'superset']),
  position: z.number().int().min(1),
  rounds: z.number().int().min(1).max(10),
  restAfter: z.number().int().min(0).max(600), // max 10 min
  exercises: z.array(workoutItemExerciseSchema).min(1),
}).refine(
  (data) => {
    if (data.type === 'exercise') return data.exercises.length === 1;
    if (data.type === 'superset') return data.exercises.length >= 2;
    return false;
  },
  { message: 'Exercice simple: 1 exercice. Superset: 2+ exercices.' }
);

const createWorkoutSchema = z.object({
  name: z.string().min(2).max(100),
  description: z.string().max(500).optional(),
  items: z.array(workoutItemSchema).min(1, 'Au moins 1 exercice ou superset requis'),
});
```

## Testing
- Tester création workout avec exercice simple
- Tester création workout avec superset (2+ exercices)
- Tester création workout mixte (exercices simples + supersets)
- Tester GET workout/:id retourne structure complète imbriquée
- Tester PUT remplace correctement les items
- Tester DELETE supprime workout et cascade (items, exercises, sets)
- Tester POST sans items → erreur 400
- Tester superset avec 1 exercice → erreur 400
- Tester exercice simple avec 2 exercices → erreur 400
- Tester duplicate crée une copie complète

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5

### File List
- `apps/api/prisma/schema.prisma` - Updated with Workout, WorkoutItem, WorkoutItemExercise, WorkoutSet models
- `apps/api/prisma/migrations/20260119203015_add_workout_models/migration.sql` - Migration for workout tables
- `apps/api/src/schemas/workout.schema.ts` - Zod validation schemas for workout API
- `apps/api/src/routes/workout.routes.ts` - CRUD routes for workouts
- `apps/api/src/routes/exercise.routes.ts` - Updated to check workout usage before delete
- `apps/api/src/index.ts` - Added workout routes

### Completion Notes
- All Prisma models created with proper relations and cascade delete
- CRUD endpoints implemented with nested create/update via transactions
- Validation prevents invalid workout structures (superset needs 2+ exercises, simple needs 1)
- Duplicate endpoint creates a full copy of the workout
- Exercise delete now checks if used in workouts and prevents deletion if so

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-17 | 0.1 | Initial story creation | PO Sarah |
| 2026-01-19 | 0.2 | Refonte complète: ajout supersets, configuration par set, repos personnalisé | PM John |
| 2026-01-19 | 1.0 | Implementation complete | Dev James |
