# Story 5.2: Endpoint POST /api/v1/health-sync

## Status: Ready for Review

## Story
**As a** companion Android app,
**I want** to send a batch of health data (daily metrics + activities + sleep) in a single API call,
**so that** data is stored in Momentum without multiplying network requests.

## Acceptance Criteria
1. `POST /health-sync` accepts the `HealthSyncRequest` payload as specified in PRD section 6.1
2. Payload validated by Zod schema (all required fields present, valid dates, positive values)
3. System TrackableItems (Pas, Minutes d'activite, Calories actives, Score sommeil) auto-created for user if they don't exist (lazy creation with values from PRD section 5.1 - Trackables systeme)
4. DailyEntry upserted on constraint `(trackableId, date)` with `source = "health_connect"`
5. HealthActivity upserted on constraint `(userId, hcRecordId)`
6. SleepRecord transformed into DailyEntry for "Score sommeil" trackable (value = score if available, else duration in minutes)
7. SyncDevice upserted with `deviceName` and `lastSyncAt`
8. Response includes count of upserted records per category
9. 400 returned for invalid payload with Zod error details
10. 401 returned for invalid token

## Tasks / Subtasks
- [x] Create Zod schema file (AC: 2, 9)
  - [x] Create `src/schemas/health-sync.schema.ts`
  - [x] Define `dailyMetricSchema` for DailyMetric validation
  - [x] Define `activityRecordSchema` for ActivityRecord validation
  - [x] Define `sleepStageSchema` for SleepStage validation
  - [x] Define `sleepRecordSchema` for SleepRecord validation
  - [x] Define `healthSyncRequestSchema` for full request body
  - [x] Export inferred types
- [x] Create route file (AC: 1, 9, 10)
  - [x] Create `src/routes/health-sync.routes.ts`
  - [x] Add ErrorCodes and formatZodError following session.routes.ts pattern
  - [x] Apply authMiddleware to all routes
  - [x] Implement POST /health-sync handler
- [x] Implement system trackable lazy creation (AC: 3)
  - [x] Define HEALTH_CONNECT_TRACKABLES constant with seed data from PRD section 5.1
  - [x] Create `ensureSystemTrackables(tx, userId)` function with proper Prisma transaction client type
  - [x] For each system trackable: findFirst by (userId, name, isSystem) or create
  - [x] Create default TrackableGoal when creating new trackable (if defaultGoal is not null)
  - [x] Return map of trackable name to ID
- [x] Implement DailyEntry upsert logic (AC: 4, 6)
  - [x] For each DailyMetric: upsert on (trackableId, date) for steps, activeCalories, activeMinutes
  - [x] Skip null values (only upsert non-null metrics)
  - [x] For each SleepRecord: upsert DailyEntry for "Score sommeil" with value = score ?? durationMinutes
  - [x] Set source = "health_connect" on all upserted entries
- [x] Implement HealthActivity upsert (AC: 5)
  - [x] For each ActivityRecord: upsert on (userId, hcRecordId)
  - [x] Map all fields from ActivityRecord to HealthActivity model
- [x] Implement SyncDevice upsert (AC: 7)
  - [x] Upsert by userId + deviceName (use findFirst + update/create pattern)
  - [x] Set lastSyncAt from request syncedAt
- [x] Wrap operations in transaction (AC: 4, 5, 7)
  - [x] Use `prisma.$transaction` for atomic upsert of all records
  - [x] Count upserted records per category within the transaction
- [x] Build response (AC: 8)
  - [x] Return synced counts: dailyMetrics, activities, sleepSessions
  - [x] Return device info: id, lastSyncAt
- [x] Mount route in index.ts
  - [x] Import healthSyncRoutes
  - [x] Mount with `app.use("/health-sync", healthSyncRoutes)` after existing routes

## Dependencies
- Story 5.1: Health Sync Data Schema (all Prisma models must exist) - **COMPLETED**

## Dev Notes

### IMPORTANT: Project Context for Fresh Session

**Zod version**: 4.3.5 (NOT v3). Import as `import { z } from "zod"` and `import { ZodError } from "zod"`. The `z.string().datetime()`, `z.infer<>`, and `error.issues` APIs all work identically to v3 in this project.

**Prisma version**: 7.2.0 with generated client at `src/generated/prisma/`. Config datasource is in `prisma.config.ts` (not in schema.prisma).

**Route prefix**: The API has NO `/api/v1` prefix. Routes mount directly (e.g., `/auth`, `/sessions`, `/health-sync`). The PRD references `/api/v1/health-sync` but the actual Express mount follows the existing convention without prefix. The Next.js frontend proxies via `/backend/[...path]`. The Android companion app calls the API directly at `http://server:3001/health-sync`.

**CORS**: The companion Android app makes native HTTP calls (Ktor/Retrofit) without Origin headers. The CORS middleware allows `!origin` so Android clients pass through without issues.

**Date handling**: `new Date("YYYY-MM-DD")` creates UTC midnight. With Prisma `@db.Date`, dates are stored as date-only in PostgreSQL. This is consistent as the companion app sends ISO date strings.

### Prisma Transaction Client Type

The `ensureSystemTrackables` helper receives a Prisma interactive transaction client. To type it correctly:

```typescript
import { PrismaClient } from "../generated/prisma/index.js";

// Extract the transaction client type from Prisma's $transaction callback
type PrismaTransactionClient = Parameters<
  Parameters<PrismaClient["$transaction"]>[0]
>[0];
```

Alternatively, use `typeof prisma` if importing the singleton:

```typescript
import { prisma } from "../lib/prisma.js";
type PrismaTransactionClient = Parameters<
  Parameters<(typeof prisma)["$transaction"]>[0]
>[0];
```

### Existing index.ts Structure (for route mounting)

File: `apps/api/src/index.ts`

Current imports and route mounts that the dev agent must work around:

```typescript
// Existing imports (DO NOT modify):
import authRoutes from "./routes/auth.routes.js";
import profileRoutes from "./routes/profile.routes.js";
import measurementRoutes from "./routes/measurement.routes.js";
import exerciseRoutes from "./routes/exercise.routes.js";
import workoutRoutes from "./routes/workout.routes.js";
import sessionRoutes from "./routes/session.routes.js";
import progressionRoutes from "./routes/progression.routes.js";
import configRoutes from "./routes/config.routes.js";
import aiCoachingRoutes from "./routes/ai-coaching.routes.js";

// ADD after aiCoachingRoutes import:
import healthSyncRoutes from "./routes/health-sync.routes.js";

// Existing route mounts:
app.use("/auth", authRoutes);
app.use("/profile", profileRoutes);
app.use("/measurements", measurementRoutes);
app.use("/exercises", exerciseRoutes);
app.use("/workouts", workoutRoutes);
app.use("/sessions", sessionRoutes);
app.use("/", progressionRoutes);
app.use("/config", configRoutes);
app.use("/sessions", aiCoachingRoutes);

// ADD after aiCoachingRoutes mount:
app.use("/health-sync", healthSyncRoutes);
```

### Zod Schema for HealthSyncRequest

File: `apps/api/src/schemas/health-sync.schema.ts`

```typescript
import { z } from "zod";

// --- Sub-schemas ---

export const dailyMetricSchema = z.object({
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be YYYY-MM-DD format"),
  steps: z.number().int().min(0).nullable(),
  activeCalories: z.number().min(0).nullable(),
  activeMinutes: z.number().min(0).nullable(),
});

export const sleepStageSchema = z.object({
  stage: z.enum(["awake", "light", "deep", "rem", "sleeping"]),
  startTime: z.string().datetime(),
  endTime: z.string().datetime(),
});

export const sleepRecordSchema = z.object({
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be YYYY-MM-DD format"),
  startTime: z.string().datetime(),
  endTime: z.string().datetime(),
  durationMinutes: z.number().min(0),
  score: z.number().int().min(0).max(100).nullable(),
  stages: z.array(sleepStageSchema).nullable(),
});

export const activityRecordSchema = z.object({
  hcRecordId: z.string().min(1, "Health Connect record ID required"),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be YYYY-MM-DD format"),
  startTime: z.string().datetime(),
  endTime: z.string().datetime(),
  activityType: z.string().min(1),
  title: z.string().nullable(),
  durationMinutes: z.number().min(0),
  calories: z.number().min(0).nullable(),
  distance: z.number().min(0).nullable(),
  heartRateAvg: z.number().int().min(0).nullable(),
  sourceApp: z.string().nullable(),
});

export const healthSyncRequestSchema = z.object({
  deviceName: z.string().min(1, "Device name is required"),
  syncedAt: z.string().datetime(),
  dailyMetrics: z.array(dailyMetricSchema).default([]),
  activities: z.array(activityRecordSchema).default([]),
  sleepSessions: z.array(sleepRecordSchema).default([]),
});

// --- Exported types ---

export type DailyMetricInput = z.infer<typeof dailyMetricSchema>;
export type SleepStageInput = z.infer<typeof sleepStageSchema>;
export type SleepRecordInput = z.infer<typeof sleepRecordSchema>;
export type ActivityRecordInput = z.infer<typeof activityRecordSchema>;
export type HealthSyncRequestInput = z.infer<typeof healthSyncRequestSchema>;
```

### Route File Structure

File: `apps/api/src/routes/health-sync.routes.ts`

Follow the same pattern as `session.routes.ts`:

```typescript
import { Router, Response } from "express";
import { prisma } from "../lib/prisma.js";
import { PrismaClient } from "../generated/prisma/index.js";
import { authMiddleware, AuthRequest } from "../middleware/auth.middleware.js";
import { healthSyncRequestSchema } from "../schemas/health-sync.schema.js";
import { ZodError } from "zod";

type PrismaTransactionClient = Parameters<
  Parameters<PrismaClient["$transaction"]>[0]
>[0];

const router = Router();

// Error codes
const ErrorCodes = {
  VALIDATION_ERROR: "VALIDATION_ERROR",
  INTERNAL_ERROR: "INTERNAL_ERROR",
} as const;

function formatZodError(error: ZodError) {
  return error.issues.map((issue) => ({
    field: issue.path.join("."),
    message: issue.message,
  }));
}

// All routes require authentication
router.use(authMiddleware);

// POST / - Sync health data batch
router.post("/", async (req: AuthRequest, res: Response) => {
  try {
    const data = healthSyncRequestSchema.parse(req.body);
    const userId = req.userId!;

    // ... implementation (see Server-side Logic below) ...

    return res.json({ synced: { ... }, device: { ... } });
  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({
        error: {
          code: ErrorCodes.VALIDATION_ERROR,
          message: "Validation failed",
          details: formatZodError(error),
        },
      });
    }
    console.error("Health sync error:", error);
    return res.status(500).json({
      error: {
        code: ErrorCodes.INTERNAL_ERROR,
        message: "An unexpected error occurred",
      },
    });
  }
});

export default router;
```

### HEALTH_CONNECT_TRACKABLES Seed Data (PRD section 5.1)

Define this constant in the route file:

```typescript
const HEALTH_CONNECT_TRACKABLES = [
  {
    name: "Pas",
    icon: "footprints",
    color: "#22C55E",
    trackingType: "number" as const,
    unit: "pas",
    isSystem: true,
    defaultGoal: { targetValue: 10000, frequency: "daily" as const },
  },
  {
    name: "Minutes d'activite",
    icon: "timer",
    color: "#3B82F6",
    trackingType: "duration" as const,
    unit: "min",
    isSystem: true,
    defaultGoal: { targetValue: 90, frequency: "daily" as const },
  },
  {
    name: "Calories actives",
    icon: "flame",
    color: "#EF4444",
    trackingType: "number" as const,
    unit: "kcal",
    isSystem: true,
    defaultGoal: { targetValue: 500, frequency: "daily" as const },
  },
  {
    name: "Score sommeil",
    icon: "moon",
    color: "#8B5CF6",
    trackingType: "number" as const,
    unit: "score",
    isSystem: true,
    defaultGoal: null,
  },
];
```

### Server-side Logic (PRD section 6.1)

```typescript
// Inside POST / handler, within prisma.$transaction:
const result = await prisma.$transaction(async (tx) => {
  // 1. Upsert SyncDevice
  let syncDevice = await tx.syncDevice.findFirst({
    where: { userId, deviceName: data.deviceName },
  });
  if (syncDevice) {
    syncDevice = await tx.syncDevice.update({
      where: { id: syncDevice.id },
      data: { lastSyncAt: new Date(data.syncedAt) },
    });
  } else {
    syncDevice = await tx.syncDevice.create({
      data: {
        userId,
        deviceName: data.deviceName,
        lastSyncAt: new Date(data.syncedAt),
      },
    });
  }

  // 2. Ensure system trackables exist for this user (lazy creation)
  const trackableMap = await ensureSystemTrackables(tx, userId);

  // 3. Upsert DailyEntries from dailyMetrics
  let dailyMetricsCount = 0;
  for (const metric of data.dailyMetrics) {
    const date = new Date(metric.date);
    const metricsToUpsert = [
      { trackableName: "Pas", value: metric.steps },
      { trackableName: "Calories actives", value: metric.activeCalories },
      { trackableName: "Minutes d'activite", value: metric.activeMinutes },
    ];

    for (const { trackableName, value } of metricsToUpsert) {
      if (value === null) continue;
      const trackableId = trackableMap.get(trackableName)!;
      await tx.dailyEntry.upsert({
        where: { trackableId_date: { trackableId, date } },
        update: { value, source: "health_connect" },
        create: { trackableId, date, value, source: "health_connect" },
      });
      dailyMetricsCount++;
    }
  }

  // 4. Upsert DailyEntries from sleepSessions
  let sleepCount = 0;
  const sleepTrackableId = trackableMap.get("Score sommeil")!;
  for (const sleep of data.sleepSessions) {
    const date = new Date(sleep.date);
    const value = sleep.score ?? sleep.durationMinutes;
    await tx.dailyEntry.upsert({
      where: { trackableId_date: { trackableId: sleepTrackableId, date } },
      update: { value, source: "health_connect" },
      create: { trackableId: sleepTrackableId, date, value, source: "health_connect" },
    });
    sleepCount++;
  }

  // 5. Upsert HealthActivities
  let activitiesCount = 0;
  for (const activity of data.activities) {
    await tx.healthActivity.upsert({
      where: {
        userId_hcRecordId: { userId, hcRecordId: activity.hcRecordId },
      },
      update: {
        date: new Date(activity.date),
        startTime: new Date(activity.startTime),
        endTime: new Date(activity.endTime),
        activityType: activity.activityType,
        title: activity.title,
        durationMinutes: activity.durationMinutes,
        calories: activity.calories,
        distance: activity.distance,
        heartRateAvg: activity.heartRateAvg,
        sourceApp: activity.sourceApp,
      },
      create: {
        userId,
        hcRecordId: activity.hcRecordId,
        date: new Date(activity.date),
        startTime: new Date(activity.startTime),
        endTime: new Date(activity.endTime),
        activityType: activity.activityType,
        title: activity.title,
        durationMinutes: activity.durationMinutes,
        calories: activity.calories,
        distance: activity.distance,
        heartRateAvg: activity.heartRateAvg,
        sourceApp: activity.sourceApp,
      },
    });
    activitiesCount++;
  }

  return {
    synced: {
      dailyMetrics: dailyMetricsCount,
      activities: activitiesCount,
      sleepSessions: sleepCount,
    },
    device: {
      id: syncDevice.id,
      lastSyncAt: syncDevice.lastSyncAt.toISOString(),
    },
  };
});

return res.json(result);
```

### ensureSystemTrackables Helper

```typescript
async function ensureSystemTrackables(
  tx: PrismaTransactionClient,
  userId: string
): Promise<Map<string, string>> {
  const trackableMap = new Map<string, string>();

  for (const trackableDef of HEALTH_CONNECT_TRACKABLES) {
    let trackable = await tx.trackableItem.findFirst({
      where: { userId, name: trackableDef.name, isSystem: true },
    });

    if (!trackable) {
      trackable = await tx.trackableItem.create({
        data: {
          userId,
          name: trackableDef.name,
          icon: trackableDef.icon,
          color: trackableDef.color,
          trackingType: trackableDef.trackingType,
          unit: trackableDef.unit,
          isSystem: true,
          isActive: true,
        },
      });

      // Create default goal if defined
      if (trackableDef.defaultGoal) {
        await tx.trackableGoal.create({
          data: {
            trackableId: trackable.id,
            targetValue: trackableDef.defaultGoal.targetValue,
            frequency: trackableDef.defaultGoal.frequency,
          },
        });
      }
    }

    trackableMap.set(trackableDef.name, trackable.id);
  }

  return trackableMap;
}
```

### Upsert Patterns

Prisma upsert relies on unique constraints:
- **DailyEntry**: `@@unique([trackableId, date])` - Prisma auto-generates `trackableId_date` compound unique identifier
- **HealthActivity**: `@@unique([userId, hcRecordId])` - Prisma auto-generates `userId_hcRecordId` compound unique identifier
- **SyncDevice**: No unique constraint on (userId, deviceName), so use `findFirst` + `update/create` pattern

### File Locations
- Zod schemas: `apps/api/src/schemas/health-sync.schema.ts`
- Route handlers: `apps/api/src/routes/health-sync.routes.ts`
- Route mounting: `apps/api/src/index.ts`

### Testing

This story contains backend business logic. Validation is manual for now (no test infrastructure exists in this project):

**Test Standards:**
- File naming: `*.test.ts` for unit, `*.integration.test.ts` for integration
- No automated test framework is set up in the API currently - all existing routes are tested manually
- All verification is manual via curl/Postman/companion app

**Manual Verification Steps:**
- POST /health-sync with valid full payload (all arrays populated) returns 200 with correct counts
- POST /health-sync with empty arrays returns 200 with zero counts
- POST /health-sync with missing required fields returns 400 with Zod error details
- POST /health-sync with invalid date format returns 400
- POST /health-sync without auth token returns 401
- POST /health-sync with expired token returns 401
- Verify system trackables are created on first sync (4 trackables + 3 goals)
- Verify system trackables are NOT re-created on second sync (idempotent)
- Verify DailyEntry upsert: send same date twice, only one record per (trackableId, date)
- Verify HealthActivity upsert: send same hcRecordId twice, only one record per (userId, hcRecordId)
- Verify SyncDevice upsert: same deviceName updates lastSyncAt, different deviceName creates new record
- Verify null metrics are skipped (steps: null should not create a DailyEntry for "Pas")
- Verify sleep score fallback: when score is null, durationMinutes is used as value
- Verify all operations are atomic (partial failure rolls back everything)

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-05 | 0.1 | Initial creation | James (Dev) |
| 2026-02-05 | 0.2 | Validation fixes: added PrismaTransactionClient type, Zod v4 note, index.ts context, route prefix clarification, template compliance | James (Dev) |

---

## Dev Agent Record

### Agent Model Used
Claude Opus 4.6

### Debug Log References
- Fixed Prisma client import path: `../generated/prisma/client.js` (not `index.js` as story dev notes suggested)

### Completion Notes List
- All 9 task groups implemented in 2 new files + 1 modified file
- TypeScript compilation passes cleanly (`npx tsc --noEmit -p apps/api`)
- Lint passes across all 3 workspaces (`npm run lint`)
- No automated tests (per story testing notes - manual verification only)

### File List
| File | Action |
|------|--------|
| `apps/api/src/schemas/health-sync.schema.ts` | Created - Zod validation schemas + exported types |
| `apps/api/src/routes/health-sync.routes.ts` | Created - POST /health-sync handler with all business logic |
| `apps/api/src/index.ts` | Modified - Added import + route mount for health-sync |

## QA Results
[Pending]
