# Story 3.3: Daily Tracking - Data Model & Backend

## Status: Draft

## Story
**As a** developer,
**I want** to store daily tracking entries,
**so that** users can log their daily habits and the system can calculate progress.

## Acceptance Criteria
1. Modèle `DailyEntry` créé (id, trackableId, date, value: number, notes nullable, createdAt)
2. Pour type boolean : value = 1 (done) ou 0 (not done)
3. Pour type number/duration : value = la valeur saisie
4. Contrainte unique sur (trackableId, date) - une seule entrée par item par jour
5. Endpoints : `GET /tracking/entries`, `GET /tracking/entries/:date`, `POST /tracking/entries` (upsert), `DELETE /tracking/entries/:id`
6. `GET /tracking/entries/:date` retourne aussi les données calculées (workout sessions du jour comptées automatiquement)
7. Endpoint summary : `GET /tracking/summary?period=week|month&date=YYYY-MM-DD` pour période avec completion %
8. Filtrage par trackableId, date range (from/to)

## Tasks / Subtasks
- [ ] Créer modèle DailyEntry (AC: 1, 2, 3, 4)
  - [ ] Migration Prisma
  - [ ] Relation avec TrackableItem
  - [ ] Value stocké comme Float (0/1 pour boolean)
  - [ ] Contrainte unique (trackableId, date)
  - [ ] Champ notes optionnel
- [ ] Créer endpoint GET entries (AC: 5, 8)
  - [ ] GET /tracking/entries - liste paginée
  - [ ] Query params: trackableId, from, to
  - [ ] Inclure trackable dans la réponse
- [ ] Créer endpoint GET entries par date (AC: 6)
  - [ ] GET /tracking/entries/:date (format YYYY-MM-DD)
  - [ ] Retourner toutes les entries du jour
  - [ ] Calculer workout sessions automatiquement
  - [ ] Inclure trackables actifs même sans entry (pour affichage dashboard)
- [ ] Créer endpoint POST upsert (AC: 5)
  - [ ] POST /tracking/entries
  - [ ] Si entry existe pour (trackableId, date): update
  - [ ] Sinon: create
  - [ ] Trigger mise à jour streak après modification
- [ ] Créer endpoint DELETE (AC: 5)
  - [ ] DELETE /tracking/entries/:id
  - [ ] Trigger recalcul streak
- [ ] Créer endpoint summary (AC: 7)
  - [ ] GET /tracking/summary?period=week|month&date=2024-01-15
  - [ ] Calculer completion % par trackable
  - [ ] Retourner stats agrégées

## Dev Notes

### Prisma Schema
```prisma
model DailyEntry {
  id          String        @id @default(uuid())
  trackableId String        @map("trackable_id")
  trackable   TrackableItem @relation(fields: [trackableId], references: [id], onDelete: Cascade)
  date        DateTime      @db.Date
  value       Float         // 0/1 for boolean, actual value for number/duration
  notes       String?
  createdAt   DateTime      @default(now()) @map("created_at")

  @@unique([trackableId, date])
  @@map("daily_entries")
}
```

### API Endpoints

```typescript
// GET /tracking/entries/:date
// Example: GET /tracking/entries/2024-01-15
Response: {
  date: "2024-01-15",
  entries: [
    {
      id: string;
      trackable: { id, name, icon, color, trackingType, unit };
      value: number;
      notes: string | null;
    }
  ],
  // Trackables actifs sans entry ce jour
  pendingTrackables: [
    { id, name, icon, color, trackingType, unit, activeGoal }
  ],
  // Workout calculé
  workoutSessions: {
    count: number;
    sessions: WorkoutSession[];
  }
}

// POST /tracking/entries (upsert)
Request: {
  trackableId: string;
  date: string; // YYYY-MM-DD
  value: number;
  notes?: string;
}

// GET /tracking/summary?period=week&date=2024-01-15
Response: {
  period: "week",
  startDate: "2024-01-08",
  endDate: "2024-01-14",
  trackables: [
    {
      id: string;
      name: string;
      goal: { targetValue, frequency };
      // Pour daily goal
      daysCompleted: number;
      totalDays: 7;
      completionPercent: 71.4;
      // Pour number type
      averageValue: number;
      totalValue: number;
    }
  ],
  overallCompletion: 75.0
}
```

### Workout Sessions Calculation
```typescript
// Pour le trackable "workout", calculer depuis WorkoutSessions
async getWorkoutEntryForDate(userId: string, date: Date) {
  const sessions = await prisma.workoutSession.findMany({
    where: {
      userId,
      status: 'completed',
      startedAt: {
        gte: startOfDay(date),
        lte: endOfDay(date),
      },
    },
  });

  return {
    count: sessions.length,
    sessions,
  };
}
```

### Upsert Logic
```typescript
async createOrUpdateEntry(data: CreateEntryInput) {
  const entry = await prisma.dailyEntry.upsert({
    where: {
      trackableId_date: {
        trackableId: data.trackableId,
        date: data.date,
      },
    },
    create: {
      trackableId: data.trackableId,
      date: data.date,
      value: data.value,
      notes: data.notes,
    },
    update: {
      value: data.value,
      notes: data.notes,
    },
    include: { trackable: true },
  });

  // Trigger streak update
  await this.streakService.updateStreak(entry.trackable.userId, entry.trackableId);

  return entry;
}
```

### Goal Completion Check
```typescript
// Vérifier si goal atteint pour une entry
const isGoalMet = (entry: DailyEntry, goal: TrackableGoal): boolean => {
  if (!goal) return false;

  switch (goal.frequency) {
    case 'daily':
      return entry.value >= goal.targetValue;
    case 'weekly':
    case 'monthly':
      // Calculé au niveau summary, pas par entry
      return false;
  }
};
```

### Validation
```typescript
const createEntrySchema = z.object({
  trackableId: z.string().uuid(),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  value: z.number().min(0),
  notes: z.string().max(500).optional(),
});
```

## Testing
- Tester création entry pour type boolean (value 0 ou 1)
- Tester création entry pour type number
- Tester création entry pour type duration
- Tester upsert (update si existe)
- Tester contrainte unique (trackableId, date)
- Tester GET entries/:date inclut workout sessions
- Tester GET entries/:date retourne pending trackables
- Tester summary calcule completion % correctement
- Tester DELETE et recalcul streak

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-17 | 0.1 | Initial story creation | PO Sarah |
