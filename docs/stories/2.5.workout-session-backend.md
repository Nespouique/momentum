# Story 2.5: Workout Session - Data Model & Backend

## Status: Ready for Review

## Story
**As a** developer,
**I want** session and set tracking models with history tracking,
**so that** workout execution can be recorded in detail and compared to previous performances.

## Acceptance Criteria

### Modèles de données
1. Modèle `WorkoutSession` créé (id, userId, workoutId, status: in_progress/completed/abandoned, startedAt, completedAt nullable, notes nullable)
2. Modèle `SessionExercise` créé pour tracker chaque exercice dans la session (id, sessionId, workoutItemExerciseId, exerciseId, status: pending/in_progress/completed/skipped/substituted, position, substitutedFromId nullable)
3. Modèle `SessionSet` créé pour les séries exécutées (id, sessionExerciseId, setNumber, targetReps, targetWeight, actualReps, actualWeight, rpe nullable 1-10, completedAt)

### Endpoints Sessions
4. `POST /sessions` - Démarrer une session (crée les SessionExercise à partir du workout)
5. `GET /sessions/:id` - Session complète avec exercices, sets et workout
6. `PATCH /sessions/:id` - Modifier status/notes
7. `DELETE /sessions/:id` - Supprimer session
8. `GET /sessions` - Historique paginé avec filtres
9. `GET /sessions/active` - Session en cours (status=in_progress)
10. `GET /sessions/last?workoutId=xxx` - **Dernière session complétée** d'un workout (pour afficher l'historique)

### Endpoints Exercices de session
11. `PATCH /sessions/:id/exercises/:exerciseId` - Modifier status (skip, substitute), réordonner
12. `POST /sessions/:id/exercises/:exerciseId/substitute` - Substituer par un autre exercice (temporaire)
13. `PUT /sessions/:id/exercises/reorder` - Réordonner les exercices (drag & drop)

### Endpoints Sets
14. `POST /sessions/:id/exercises/:exerciseId/sets` - Ajouter un set avec résultats
15. `PUT /sessions/:id/sets/:setId` - Modifier un set
16. `DELETE /sessions/:id/sets/:setId` - Supprimer un set

### Logique métier
17. Calcul automatique de duration à la complétion (completedAt - startedAt)
18. Filtrage historique par status, workoutId, date range (from/to), pagination (limit/offset)
19. Une seule session active par utilisateur à la fois

## Tasks / Subtasks

### Modèles de données
- [x] Créer modèle WorkoutSession (AC: 1)
  - [x] Migration Prisma
  - [x] Enum SessionStatus: in_progress, completed, abandoned
  - [x] Relations avec User et Workout
- [x] Créer modèle SessionExercise (AC: 2)
  - [x] Migration Prisma
  - [x] Enum ExerciseStatus: pending, in_progress, completed, skipped, substituted
  - [x] Relation avec WorkoutSession, WorkoutItemExercise, Exercise
  - [x] Champ position pour le réordonnancement
  - [x] Champ substitutedFromId pour tracker les substitutions
- [x] Créer modèle SessionSet (AC: 3)
  - [x] Migration Prisma
  - [x] Relation avec SessionExercise
  - [x] Champs target (targetReps, targetWeight) et actual (actualReps, actualWeight)
  - [x] Champ rpe optionnel (1-10)

### Endpoints Sessions
- [x] POST /sessions (AC: 4)
  - [x] Vérifier qu'aucune session active n'existe (AC: 19)
  - [x] Créer la session avec status in_progress
  - [x] Créer automatiquement les SessionExercise à partir du Workout
  - [x] Retourner la session complète avec exercices et targets
- [x] GET /sessions/:id (AC: 5)
  - [x] Inclure workout, exercices, sets
  - [x] Inclure données de la dernière session pour comparaison
- [x] PATCH /sessions/:id (AC: 6)
  - [x] Modifier status (completed/abandoned) et notes
  - [x] Calculer duration à la complétion (AC: 17)
- [x] DELETE /sessions/:id (AC: 7)
- [x] GET /sessions (AC: 8, 18)
  - [x] Filtres: status, workoutId, from, to
  - [x] Pagination: limit, offset
  - [x] Tri par date décroissante
- [x] GET /sessions/active (AC: 9)
- [x] GET /sessions/last (AC: 10)
  - [x] Query param workoutId requis
  - [x] Retourner la dernière session completed de ce workout
  - [x] Inclure tous les sets pour comparaison

### Endpoints Exercices de session
- [x] PATCH /sessions/:id/exercises/:exerciseId (AC: 11)
  - [x] Modifier status (skip → passer l'exercice)
- [x] POST /sessions/:id/exercises/:exerciseId/substitute (AC: 12)
  - [x] Créer un nouveau SessionExercise avec le nouvel exerciseId
  - [x] Marquer l'ancien comme "substituted"
  - [x] Stocker substitutedFromId pour référence
- [x] PUT /sessions/:id/exercises/reorder (AC: 13)
  - [x] Recevoir un tableau d'IDs dans le nouvel ordre
  - [x] Mettre à jour les positions

### Endpoints Sets
- [x] POST /sessions/:id/exercises/:exerciseId/sets (AC: 14)
  - [x] Créer un set avec actualReps et actualWeight
  - [x] Valider que la session est in_progress
- [x] PUT /sessions/:id/sets/:setId (AC: 15)
  - [x] Modifier actualReps, actualWeight, rpe
- [x] DELETE /sessions/:id/sets/:setId (AC: 16)

## Dependencies
- Story 1.2: Database & Prisma Setup (Prisma 7 configuration)
- Story 2.3: Workout Program Backend (modèle Workout pour relation)
- Story 2.1: Exercise Library Backend (modèle Exercise pour relation Set)

## Dev Notes

### Prisma 7 Configuration (ref Story 1.2)
- La config datasource est dans `prisma.config.ts` (pas dans schema.prisma)
- Le client est généré dans `src/generated/prisma/`
- Utiliser `moduleFormat = "cjs"` dans le generator
- Import Prisma: `import { prisma } from '../lib/prisma'`

### Contrainte Business Importante
**Une seule session active par utilisateur:**
```typescript
// Avant de créer une session, vérifier qu'il n'y en a pas déjà une active
const existingSession = await prisma.workoutSession.findFirst({
  where: { userId, status: 'in_progress' }
});
if (existingSession) {
  return res.status(409).json({ error: 'SESSION_ALREADY_ACTIVE' });
}
```

### Architecture des modèles

```
WorkoutSession (session en cours)
├── id, userId, workoutId, status, startedAt, completedAt, notes
└── exercises[] (SessionExercise)
    │
    ├── SessionExercise (exercice dans la session)
    │   ├── id, sessionId, workoutItemExerciseId, exerciseId
    │   ├── status: pending/in_progress/completed/skipped/substituted
    │   ├── position (pour réordonnancement)
    │   ├── substitutedFromId (si substitué)
    │   └── sets[] (SessionSet)
    │       └── SessionSet
    │           ├── targetReps, targetWeight (objectifs du workout)
    │           └── actualReps, actualWeight (résultats réels)
```

### Prisma Schema

```prisma
enum SessionStatus {
  in_progress
  completed
  abandoned
}

enum SessionExerciseStatus {
  pending
  in_progress
  completed
  skipped
  substituted
}

model WorkoutSession {
  id          String        @id @default(uuid())
  userId      String        @map("user_id")
  user        User          @relation(fields: [userId], references: [id])
  workoutId   String        @map("workout_id")
  workout     Workout       @relation(fields: [workoutId], references: [id])
  status      SessionStatus @default(in_progress)
  startedAt   DateTime      @default(now()) @map("started_at")
  completedAt DateTime?     @map("completed_at")
  notes       String?

  exercises SessionExercise[]

  @@map("workout_sessions")
}

model SessionExercise {
  id                    String                @id @default(uuid())
  sessionId             String                @map("session_id")
  session               WorkoutSession        @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  workoutItemExerciseId String?               @map("workout_item_exercise_id")
  workoutItemExercise   WorkoutItemExercise?  @relation(fields: [workoutItemExerciseId], references: [id])
  exerciseId            String                @map("exercise_id")
  exercise              Exercise              @relation(fields: [exerciseId], references: [id])
  status                SessionExerciseStatus @default(pending)
  position              Int                   // Ordre dans la session (modifiable via drag & drop)
  substitutedFromId     String?               @map("substituted_from_id") // ID de l'exercice original si substitué

  // Pour les supersets : référence au WorkoutItem parent
  workoutItemId         String?               @map("workout_item_id")
  workoutItem           WorkoutItem?          @relation(fields: [workoutItemId], references: [id])

  sets SessionSet[]

  @@index([sessionId, position])
  @@map("session_exercises")
}

model SessionSet {
  id                String          @id @default(uuid())
  sessionExerciseId String          @map("session_exercise_id")
  sessionExercise   SessionExercise @relation(fields: [sessionExerciseId], references: [id], onDelete: Cascade)
  setNumber         Int             @map("set_number")

  // Objectifs (copiés depuis WorkoutSet au démarrage)
  targetReps        Int             @map("target_reps")
  targetWeight      Float?          @map("target_weight")

  // Résultats réels (saisis par l'utilisateur)
  actualReps        Int?            @map("actual_reps")
  actualWeight      Float?          @map("actual_weight")

  rpe               Int?            // Rate of Perceived Exertion 1-10
  completedAt       DateTime?       @map("completed_at")

  @@index([sessionExerciseId, setNumber])
  @@map("session_sets")
}
```

### API Endpoints

```typescript
// POST /sessions - Démarrer une session
Request: { workoutId: string }
Response: {
  session: WorkoutSession;
  exercises: SessionExercise[]; // avec targets pré-remplis
  lastSession?: WorkoutSession; // pour comparaison historique
}

// GET /sessions/last?workoutId=xxx - Dernière session complétée
Response: WorkoutSession (avec tous les sets pour comparaison)

// GET /sessions/active
Response: WorkoutSession | null (avec exercices et sets en cours)

// GET /sessions?status=completed&workoutId=xxx&from=2024-01-01&to=2024-01-31&limit=20&offset=0
Response: {
  data: WorkoutSession[];
  total: number;
  limit: number;
  offset: number;
}

// PATCH /sessions/:id
Request: {
  status?: 'completed' | 'abandoned';
  notes?: string;
}

// PATCH /sessions/:id/exercises/:exerciseId - Skip un exercice
Request: { status: 'skipped' }

// POST /sessions/:id/exercises/:exerciseId/substitute - Substituer
Request: { newExerciseId: string }
Response: SessionExercise (nouvel exercice créé)

// PUT /sessions/:id/exercises/reorder - Réordonner
Request: { exerciseIds: string[] } // Nouvel ordre
Response: SessionExercise[]

// POST /sessions/:id/exercises/:exerciseId/sets - Enregistrer résultat série
Request: {
  setNumber: number;
  actualReps: number;
  actualWeight: number;
  rpe?: number;
}
```

### Logique de démarrage de session

```typescript
async startSession(userId: string, workoutId: string) {
  // 1. Vérifier pas de session active
  // 2. Charger le workout complet avec items et exercices
  // 3. Créer la session
  // 4. Créer les SessionExercise avec targets copiés
  // 5. Charger la dernière session completed pour historique

  return prisma.$transaction(async (tx) => {
    const workout = await tx.workout.findUnique({
      where: { id: workoutId },
      include: {
        items: {
          orderBy: { position: 'asc' },
          include: {
            exercises: {
              orderBy: { position: 'asc' },
              include: {
                exercise: true,
                sets: { orderBy: { setNumber: 'asc' } }
              }
            }
          }
        }
      }
    });

    const session = await tx.workoutSession.create({
      data: {
        userId,
        workoutId,
        exercises: {
          create: flattenExercises(workout.items).map((ex, index) => ({
            workoutItemExerciseId: ex.id,
            exerciseId: ex.exerciseId,
            workoutItemId: ex.workoutItemId,
            position: index,
            sets: {
              create: ex.sets.map(set => ({
                setNumber: set.setNumber,
                targetReps: set.targetReps,
                targetWeight: set.targetWeight,
              }))
            }
          }))
        }
      }
    });

    // Charger dernière session pour historique
    const lastSession = await tx.workoutSession.findFirst({
      where: { userId, workoutId, status: 'completed' },
      orderBy: { completedAt: 'desc' },
      include: { exercises: { include: { sets: true } } }
    });

    return { session, lastSession };
  });
}
```

### Validation Rules
- Seul le owner peut modifier sa session
- Sets ne peuvent être ajoutés que si session est in_progress
- RPE doit être entre 1 et 10 si fourni
- Une seule session in_progress par utilisateur à la fois
- Substitution : le nouvel exercice doit exister
- Réordonnancement : tous les IDs doivent appartenir à la session

### Zod Schemas

```typescript
const createSessionSchema = z.object({
  workoutId: z.string().uuid(),
});

const recordSetResultSchema = z.object({
  setNumber: z.number().int().positive(),
  actualReps: z.number().int().min(0).max(100),
  actualWeight: z.number().min(0).max(1000),
  rpe: z.number().int().min(1).max(10).optional(),
});

const substituteExerciseSchema = z.object({
  newExerciseId: z.string().uuid(),
});

const reorderExercisesSchema = z.object({
  exerciseIds: z.array(z.string().uuid()),
});

const updateSessionSchema = z.object({
  status: z.enum(['completed', 'abandoned']).optional(),
  notes: z.string().max(1000).optional(),
});

const skipExerciseSchema = z.object({
  status: z.literal('skipped'),
});
```

## Testing

### Sessions
- Tester démarrage session → status in_progress, SessionExercise créés avec targets
- Tester qu'on ne peut démarrer qu'une session à la fois
- Tester GET /sessions/last retourne la dernière session completed
- Tester complétion → completedAt défini, duration calculée
- Tester abandon → status abandoned
- Tester GET /sessions/active retourne session en cours avec exercices et sets
- Tester filtrage par date range et workoutId
- Tester pagination

### Exercices de session
- Tester skip exercice → status skipped
- Tester substitution → nouvel exercice créé, ancien marqué substituted
- Tester réordonnancement → positions mises à jour
- Tester que substitution ne modifie pas le workout original

### Sets
- Tester enregistrement résultat série (actualReps, actualWeight)
- Tester modification de set
- Tester suppression de set
- Tester validation RPE entre 1 et 10

### Historique
- Tester que lastSession contient les sets de la session précédente
- Tester correspondance exercice/set pour comparaison

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-17 | 0.1 | Initial story creation | PO Sarah |
| 2026-01-21 | 0.2 | Refonte complète : SessionExercise, SessionSet, historique, skip/substitute/reorder | PM John & UX Sally |
| 2026-01-21 | 1.0 | Implementation complete | Dev James |

---

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5

### File List
| File | Action | Description |
|------|--------|-------------|
| `apps/api/prisma/schema.prisma` | Modified | Added SessionStatus, SessionExerciseStatus enums; WorkoutSession, SessionExercise, SessionSet models |
| `apps/api/prisma/migrations/20260121164109_add_workout_session_models/migration.sql` | Created | Migration for new session models |
| `apps/api/src/schemas/session.schema.ts` | Created | Zod validation schemas for all session endpoints |
| `apps/api/src/routes/session.routes.ts` | Created | Express routes for all session API endpoints |
| `apps/api/src/index.ts` | Modified | Added session routes import and mount |

### Completion Notes
- All 19 acceptance criteria implemented
- Models follow existing Prisma conventions (@map for snake_case columns)
- Routes follow existing patterns (error codes, Zod validation, auth middleware)
- One active session per user constraint enforced with 409 CONFLICT response
- Session start creates SessionExercise and SessionSet from workout structure
- Last session comparison data included in GET responses
- completedAt automatically set when status changes to completed/abandoned

### Debug Log References
None - implementation completed without issues
