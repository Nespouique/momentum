# Story 3.5: Streaks Calculation System

## Status: Draft

## Story
**As a** developer,
**I want** to calculate and store streak data,
**so that** users can see their consistency over time.

## Acceptance Criteria
1. Modèle `Streak` créé (id, userId, trackableId nullable, currentStreak, longestStreak, lastActivityDate, updatedAt)
2. trackableId = null pour le streak global workout
3. Logique de calcul : streak = jours consécutifs où l'objectif a été atteint
4. Pour objectif quotidien : chaque jour compte
5. Pour objectif hebdomadaire/mensuel : streak = périodes consécutives où l'objectif atteint
6. Mise à jour automatique des streaks lors de chaque entrée de tracking
7. Reset du streak si une période est manquée (selon frequency de l'objectif)
8. Endpoints : `GET /streaks` (tous les streaks), `GET /streaks/:trackableId`, `GET /streaks/workout` (streak global workout)
9. Gestion du edge case : jour en cours ne casse pas le streak tant qu'il n'est pas terminé

## Tasks / Subtasks
- [ ] Créer modèle Streak (AC: 1, 2)
  - [ ] Migration Prisma
  - [ ] trackableId nullable (null = workout global)
  - [ ] Relations avec User et TrackableItem
  - [ ] Champs: currentStreak, longestStreak, lastActivityDate
- [ ] Implémenter calcul streak quotidien (AC: 3, 4)
  - [ ] Service `streak.service.ts`
  - [ ] Logique: compter jours consécutifs avec entry value >= goal
  - [ ] Incrémenter si day = lastActivityDate + 1
  - [ ] Reset si day > lastActivityDate + 1
- [ ] Implémenter calcul streak périodique (AC: 5)
  - [ ] Pour weekly: compter semaines consécutives où goal atteint
  - [ ] Pour monthly: compter mois consécutifs où goal atteint
  - [ ] Calculer à la fin de chaque période
- [ ] Trigger mise à jour automatique (AC: 6)
  - [ ] Hook après création/modification DailyEntry
  - [ ] Hook après complétion WorkoutSession
  - [ ] Appeler streakService.updateStreak()
- [ ] Implémenter reset logic (AC: 7)
  - [ ] Détecter si période manquée
  - [ ] Reset currentStreak à 0 (ou 1 si activité aujourd'hui)
  - [ ] Conserver longestStreak
- [ ] Créer endpoints (AC: 8)
  - [ ] GET /streaks - tous les streaks de l'utilisateur
  - [ ] GET /streaks/:trackableId - streak pour un trackable
  - [ ] GET /streaks/workout - streak global (sessions)
- [ ] Gérer edge case jour en cours (AC: 9)
  - [ ] Ne pas casser streak si today pas encore complété
  - [ ] Indicateur "at risk" si on approche minuit
  - [ ] Logique: streak cassé seulement quand day > lastActivityDate + 1

## Dev Notes

### Prisma Schema
```prisma
model Streak {
  id               String         @id @default(uuid())
  userId           String         @map("user_id")
  user             User           @relation(fields: [userId], references: [id])
  trackableId      String?        @map("trackable_id")
  trackable        TrackableItem? @relation(fields: [trackableId], references: [id], onDelete: Cascade)
  currentStreak    Int            @default(0) @map("current_streak")
  longestStreak    Int            @default(0) @map("longest_streak")
  lastActivityDate DateTime       @map("last_activity_date")
  updatedAt        DateTime       @updatedAt @map("updated_at")

  @@unique([userId, trackableId])
  @@map("streaks")
}
```

### Streak Calculation Algorithm
```typescript
// streak.service.ts
async updateStreak(userId: string, trackableId: string | null) {
  const streak = await this.getOrCreateStreak(userId, trackableId);
  const today = startOfDay(new Date());
  const lastActivity = startOfDay(streak.lastActivityDate);

  const daysDiff = differenceInDays(today, lastActivity);

  let newStreak = streak.currentStreak;

  if (daysDiff === 0) {
    // Same day, already counted - no change needed
    return streak;
  } else if (daysDiff === 1) {
    // Consecutive day - increment streak
    newStreak = streak.currentStreak + 1;
  } else if (daysDiff > 1) {
    // Streak broken - reset to 1 (today counts)
    newStreak = 1;
  }

  // Update longest if needed
  const newLongest = Math.max(streak.longestStreak, newStreak);

  return prisma.streak.update({
    where: { id: streak.id },
    data: {
      currentStreak: newStreak,
      longestStreak: newLongest,
      lastActivityDate: today,
    },
  });
}
```

### Weekly/Monthly Streak Logic
```typescript
async updatePeriodicStreak(
  userId: string,
  trackableId: string,
  frequency: 'weekly' | 'monthly'
) {
  const goal = await this.getActiveGoal(trackableId);
  const period = frequency === 'weekly' ? 'week' : 'month';

  // Get entries for the period that just ended
  const periodStart = startOf(subPeriods(new Date(), 1), period);
  const periodEnd = endOf(subPeriods(new Date(), 1), period);

  const entries = await prisma.dailyEntry.findMany({
    where: {
      trackableId,
      date: { gte: periodStart, lte: periodEnd },
    },
  });

  // Check if goal was met
  const totalValue = entries.reduce((sum, e) => sum + e.value, 0);
  const goalMet = totalValue >= goal.targetValue;

  // Update streak accordingly
  const streak = await this.getOrCreateStreak(userId, trackableId);

  if (goalMet) {
    // Increment or start streak
    await this.incrementStreak(streak);
  } else {
    // Reset streak
    await this.resetStreak(streak);
  }
}
```

### API Endpoints
```typescript
// GET /streaks
Response: {
  data: [
    {
      id: string;
      trackableId: string | null;
      trackable: { name, icon } | null;
      type: 'workout' | 'trackable';
      currentStreak: number;
      longestStreak: number;
      lastActivityDate: string;
      atRisk: boolean; // true si aujourd'hui pas encore fait
    }
  ],
  globalStreak: {
    currentStreak: number; // jours avec au moins 1 activité
    longestStreak: number;
  }
}

// GET /streaks/workout
Response: {
  currentStreak: number;
  longestStreak: number;
  lastActivityDate: string;
  atRisk: boolean;
}
```

### At Risk Detection
```typescript
const isAtRisk = (streak: Streak): boolean => {
  const today = startOfDay(new Date());
  const lastActivity = startOfDay(streak.lastActivityDate);
  const daysDiff = differenceInDays(today, lastActivity);

  // At risk if no activity today and streak > 0
  return daysDiff >= 1 && streak.currentStreak > 0;
};
```

### Workout Global Streak
```typescript
// Streak spécial calculé depuis WorkoutSessions
async updateWorkoutStreak(userId: string) {
  const today = startOfDay(new Date());

  // Vérifier si workout complété aujourd'hui
  const todaySession = await prisma.workoutSession.findFirst({
    where: {
      userId,
      status: 'completed',
      startedAt: { gte: today },
    },
  });

  if (todaySession) {
    await this.updateStreak(userId, null); // null = workout streak
  }
}
```

### Edge Cases
1. **Nouveau utilisateur**: Streak commence à 0, première activité = 1
2. **Changement de timezone**: Utiliser timezone user pour calcul jour
3. **Activité multiple même jour**: Ne compte qu'une fois
4. **Fin de période (weekly/monthly)**: Job cron ou calcul lazy

## Testing
- Tester création streak au premier entry
- Tester incrémentation jour consécutif
- Tester reset après jour manqué
- Tester que longestStreak ne diminue jamais
- Tester streak workout (null trackableId)
- Tester atRisk correctement calculé
- Tester edge case: même jour, plusieurs activités
- Tester que jour en cours ne casse pas streak

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-17 | 0.1 | Initial story creation | PO Sarah |
