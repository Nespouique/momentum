# Story 1.7: CI/CD Pipeline & Production Docker

## Status: Draft

## Story
**As a** developer,
**I want** automated build, test, and deployment pipeline,
**so that** I can deploy reliably to my Proxmox server.

## Acceptance Criteria
1. Dockerfile multi-stage pour frontend (Next.js standalone)
2. Dockerfile pour backend (Express)
3. Docker Compose production avec services web, api, postgres
4. GitHub Actions workflow : lint, build, push images to DockerHub
5. Images taguées avec version (git sha ou semver)
6. Variables d'environnement production documentées
7. Health check endpoints (`/health`) sur frontend et backend
8. README avec instructions de déploiement

## Tasks / Subtasks
- [ ] Créer Dockerfile frontend (AC: 1)
  - [ ] Multi-stage build: deps → builder → runner
  - [ ] Utiliser Next.js standalone output
  - [ ] Optimiser pour taille d'image minimale
  - [ ] Exposer port 3000
- [ ] Créer Dockerfile backend (AC: 2)
  - [ ] Multi-stage build
  - [ ] Compiler TypeScript → JavaScript
  - [ ] Copier seulement les fichiers nécessaires
  - [ ] Exposer port 3001
- [ ] Créer Docker Compose production (AC: 3)
  - [ ] Service web (frontend) avec healthcheck
  - [ ] Service api (backend) avec healthcheck
  - [ ] Service postgres avec volume persistant
  - [ ] Network interne pour communication
  - [ ] Variables d'environnement via .env
- [ ] Créer GitHub Actions workflow (AC: 4, 5)
  - [ ] Trigger: push sur main, pull requests
  - [ ] Job: lint (ESLint)
  - [ ] Job: build & test
  - [ ] Job: build & push Docker images (main only)
  - [ ] Utiliser secrets pour DockerHub credentials
  - [ ] Tag images avec sha et latest
- [ ] Créer health endpoints (AC: 7)
  - [ ] GET /health sur backend → { status: "ok", timestamp }
  - [ ] GET /api/health sur frontend (API route) ou page
  - [ ] Vérifier connexion DB dans health check backend
- [ ] Documentation (AC: 6, 8)
  - [ ] Créer `.env.production.example`
  - [ ] Documenter toutes les variables requises
  - [ ] README section déploiement:
    - Pull images
    - Configuration
    - docker-compose up
    - Nginx Proxy Manager setup

## Dev Notes

### Dockerfile Frontend (Multi-stage)
```dockerfile
# Stage 1: Dependencies
FROM node:20-alpine AS deps
WORKDIR /app
COPY package*.json ./
COPY apps/web/package*.json ./apps/web/
RUN npm ci --workspace=apps/web

# Stage 2: Builder
FROM node:20-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
ENV NEXT_TELEMETRY_DISABLED 1
RUN npm run build --workspace=apps/web

# Stage 3: Runner
FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV production
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs
COPY --from=builder /app/apps/web/.next/standalone ./
COPY --from=builder /app/apps/web/.next/static ./apps/web/.next/static
COPY --from=builder /app/apps/web/public ./apps/web/public
USER nextjs
EXPOSE 3000
CMD ["node", "apps/web/server.js"]
```

### Dockerfile Backend
```dockerfile
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
COPY apps/api/package*.json ./apps/api/
COPY packages/shared/package*.json ./packages/shared/
RUN npm ci
COPY . .
RUN npm run build --workspace=apps/api

FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV production
COPY --from=builder /app/apps/api/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/apps/api/package.json ./
EXPOSE 3001
CMD ["node", "dist/index.js"]
```

### Docker Compose Production
```yaml
version: '3.8'
services:
  web:
    image: yourusername/momentum-web:latest
    ports:
      - "3000:3000"
    environment:
      - NEXT_PUBLIC_API_URL=http://api:3001
    depends_on:
      api:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  api:
    image: yourusername/momentum-api:latest
    ports:
      - "3001:3001"
    environment:
      - DATABASE_URL=postgresql://momentum:${DB_PASSWORD}@postgres:5432/momentum
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  postgres:
    image: postgres:16-alpine
    environment:
      - POSTGRES_USER=momentum
      - POSTGRES_PASSWORD=${DB_PASSWORD}
      - POSTGRES_DB=momentum
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U momentum"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
```

### GitHub Actions Workflow
```yaml
name: CI/CD
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - run: npm run lint

  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - run: npm run build

  docker:
    needs: [lint, build]
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile.web
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/momentum-web:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/momentum-web:${{ github.sha }}
```

### Variables d'environnement production
```
# .env.production.example
DATABASE_URL=postgresql://momentum:PASSWORD@postgres:5432/momentum
JWT_SECRET=your-super-secret-jwt-key-min-32-chars
NEXT_PUBLIC_API_URL=https://api.momentum.yourdomain.com
```

### Health Check Endpoint
```typescript
// Backend
app.get('/health', async (req, res) => {
  try {
    await prisma.$queryRaw`SELECT 1`;
    res.json({ status: 'ok', timestamp: new Date().toISOString() });
  } catch (error) {
    res.status(503).json({ status: 'error', message: 'Database unavailable' });
  }
});
```

## Testing
- Tester build Docker local des deux images
- Tester docker-compose up démarre les 3 services
- Tester que /health répond 200 sur les deux services
- Tester que le workflow GitHub Actions passe sur une PR
- Vérifier que les images sont poussées sur DockerHub après merge

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-17 | 0.1 | Initial story creation | PO Sarah |
